{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CsvConfigConsts = function () {\n  function CsvConfigConsts() {}\n\n  CsvConfigConsts.EOL = \"\\r\\n\";\n  CsvConfigConsts.BOM = \"\\uFEFF\";\n  CsvConfigConsts.DEFAULT_FIELD_SEPARATOR = ',';\n  CsvConfigConsts.DEFAULT_DECIMAL_SEPARATOR = '.';\n  CsvConfigConsts.DEFAULT_QUOTE = '\"';\n  CsvConfigConsts.DEFAULT_SHOW_TITLE = false;\n  CsvConfigConsts.DEFAULT_TITLE = 'My Generated Report';\n  CsvConfigConsts.DEFAULT_FILENAME = 'generated';\n  CsvConfigConsts.DEFAULT_SHOW_LABELS = false;\n  CsvConfigConsts.DEFAULT_USE_TEXT_FILE = false;\n  CsvConfigConsts.DEFAULT_USE_BOM = true;\n  CsvConfigConsts.DEFAULT_HEADER = [];\n  CsvConfigConsts.DEFAULT_KEYS_AS_HEADERS = false;\n  return CsvConfigConsts;\n}();\n\nexports.CsvConfigConsts = CsvConfigConsts;\nexports.ConfigDefaults = {\n  filename: CsvConfigConsts.DEFAULT_FILENAME,\n  fieldSeparator: CsvConfigConsts.DEFAULT_FIELD_SEPARATOR,\n  quoteStrings: CsvConfigConsts.DEFAULT_QUOTE,\n  decimalSeparator: CsvConfigConsts.DEFAULT_DECIMAL_SEPARATOR,\n  showLabels: CsvConfigConsts.DEFAULT_SHOW_LABELS,\n  showTitle: CsvConfigConsts.DEFAULT_SHOW_TITLE,\n  title: CsvConfigConsts.DEFAULT_TITLE,\n  useTextFile: CsvConfigConsts.DEFAULT_USE_TEXT_FILE,\n  useBom: CsvConfigConsts.DEFAULT_USE_BOM,\n  headers: CsvConfigConsts.DEFAULT_HEADER,\n  useKeysAsHeaders: CsvConfigConsts.DEFAULT_KEYS_AS_HEADERS\n};\n\nvar ExportToCsv = function () {\n  function ExportToCsv(options) {\n    this._csv = \"\";\n    var config = options || {};\n    this._options = objectAssign({}, exports.ConfigDefaults, config);\n\n    if (this._options.useKeysAsHeaders && this._options.headers && this._options.headers.length > 0) {\n      console.warn('Option to use object keys as headers was set, but headers were still passed!');\n    }\n  }\n\n  Object.defineProperty(ExportToCsv.prototype, \"options\", {\n    get: function get() {\n      return this._options;\n    },\n    set: function set(options) {\n      this._options = objectAssign({}, exports.ConfigDefaults, options);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Generate and Download Csv\n   */\n\n  ExportToCsv.prototype.generateCsv = function (jsonData, shouldReturnCsv) {\n    if (shouldReturnCsv === void 0) {\n      shouldReturnCsv = false;\n    } // Make sure to reset csv data on each run\n\n\n    this._csv = '';\n\n    this._parseData(jsonData);\n\n    if (this._options.useBom) {\n      this._csv += CsvConfigConsts.BOM;\n    }\n\n    if (this._options.showTitle) {\n      this._csv += this._options.title + '\\r\\n\\n';\n    }\n\n    this._getHeaders();\n\n    this._getBody();\n\n    if (this._csv == '') {\n      console.log(\"Invalid data\");\n      return;\n    } // When the consumer asks for the data, exit the function\n    // by returning the CSV data built at this point\n\n\n    if (shouldReturnCsv) {\n      return this._csv;\n    } // Create CSV blob to download if requesting in the browser and the\n    // consumer doesn't set the shouldReturnCsv param\n\n\n    var FileType = this._options.useTextFile ? 'plain' : 'csv';\n    var fileExtension = this._options.useTextFile ? '.txt' : '.csv';\n    var blob = new Blob([this._csv], {\n      \"type\": \"text/\" + FileType + \";charset=utf8;\"\n    });\n\n    if (navigator.msSaveBlob) {\n      var filename = this._options.filename.replace(/ /g, \"_\") + fileExtension;\n      navigator.msSaveBlob(blob, filename);\n    } else {\n      var attachmentType = this._options.useTextFile ? 'text' : 'csv';\n      var uri = 'data:attachment/' + attachmentType + ';charset=utf-8,' + encodeURI(this._csv);\n      var link = document.createElement(\"a\");\n      link.href = URL.createObjectURL(blob);\n      link.setAttribute('visibility', 'hidden');\n      link.download = this._options.filename.replace(/ /g, \"_\") + fileExtension;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n  /**\n   * Create Headers\n   */\n\n\n  ExportToCsv.prototype._getHeaders = function () {\n    if (!this._options.showLabels && !this._options.useKeysAsHeaders) {\n      return;\n    }\n\n    var useKeysAsHeaders = this._options.useKeysAsHeaders;\n    var headers = useKeysAsHeaders ? Object.keys(this._data[0]) : this._options.headers;\n\n    if (headers.length > 0) {\n      var row = \"\";\n\n      for (var keyPos = 0; keyPos < headers.length; keyPos++) {\n        row += headers[keyPos] + this._options.fieldSeparator;\n      }\n\n      row = row.slice(0, -1);\n      this._csv += row + CsvConfigConsts.EOL;\n    }\n  };\n  /**\n   * Create Body\n   */\n\n\n  ExportToCsv.prototype._getBody = function () {\n    var keys = Object.keys(this._data[0]);\n\n    for (var i = 0; i < this._data.length; i++) {\n      var row = \"\";\n\n      for (var keyPos = 0; keyPos < keys.length; keyPos++) {\n        var key = keys[keyPos];\n        row += this._formatData(this._data[i][key]) + this._options.fieldSeparator;\n      }\n\n      row = row.slice(0, -1);\n      this._csv += row + CsvConfigConsts.EOL;\n    }\n  };\n  /**\n   * Format Data\n   * @param {any} data\n   */\n\n\n  ExportToCsv.prototype._formatData = function (data) {\n    if (this._options.decimalSeparator === 'locale' && this._isFloat(data)) {\n      return data.toLocaleString();\n    }\n\n    if (this._options.decimalSeparator !== '.' && this._isFloat(data)) {\n      return data.toString().replace('.', this._options.decimalSeparator);\n    }\n\n    if (typeof data === 'string') {\n      data = data.replace(/\"/g, '\"\"');\n\n      if (this._options.quoteStrings || data.indexOf(',') > -1 || data.indexOf('\\n') > -1 || data.indexOf('\\r') > -1) {\n        data = this._options.quoteStrings + data + this._options.quoteStrings;\n      }\n\n      return data;\n    }\n\n    if (typeof data === 'boolean') {\n      return data ? 'TRUE' : 'FALSE';\n    }\n\n    return data;\n  };\n  /**\n   * Check if is Float\n   * @param {any} input\n   */\n\n\n  ExportToCsv.prototype._isFloat = function (input) {\n    return +input === input && (!isFinite(input) || Boolean(input % 1));\n  };\n  /**\n   * Parse the collection given to it\n   *\n   * @private\n   * @param {*} jsonData\n   * @returns {any[]}\n   * @memberof ExportToCsv\n   */\n\n\n  ExportToCsv.prototype._parseData = function (jsonData) {\n    this._data = typeof jsonData != 'object' ? JSON.parse(jsonData) : jsonData;\n    return this._data;\n  };\n\n  return ExportToCsv;\n}();\n\nexports.ExportToCsv = ExportToCsv;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n/**\n * Convet to Object\n * @param {any} val\n */\n\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n/**\n * Assign data  to new Object\n * @param {any}   target\n * @param {any[]} ...source\n */\n\n\nfunction objectAssign(target) {\n  var source = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    source[_i - 1] = arguments[_i];\n  }\n\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n}","map":null,"metadata":{},"sourceType":"script"}